import { useState, useEffect } from "react";
import { Connection, PublicKey } from "@solana/web3.js";
import { Program, AnchorProvider, Idl } from "@coral-xyz/anchor";
import { getConnection, PROGRAM_ID } from "../lib/program";

export interface LobAccount {
  address: PublicKey;
  owner: PublicKey;
  name: string;
  species: number;
  xp: number;
  strength: number;
  vitality: number;
  speed: number;
  mood: number;
  lastFed: number;
  battlesWon: number;
  battlesLost: number;
  evolutionStage: number;
  isAlive: boolean;
  mintIndex: number;
}

// Lob account discriminator (first 8 bytes of sha256("account:Lob"))
// This is generated by Anchor â€” we hardcode for read-only access
const LOB_ACCOUNT_SIZE = 8 + 32 + (4 + 32) + 1 + 4 + 1 + 1 + 1 + 1 + 8 + 4 + 4 + 1 + 1 + 8 + 1;

export function useLobs() {
  const [lobs, setLobs] = useState<LobAccount[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    let cancelled = false;

    async function fetchLobs() {
      try {
        const connection = getConnection();

        // Fetch all program accounts that match Lob structure
        const accounts = await connection.getProgramAccounts(PROGRAM_ID, {
          commitment: "confirmed",
        });

        if (cancelled) return;

        const parsed: LobAccount[] = [];

        for (const { pubkey, account } of accounts) {
          try {
            const data = account.data;
            // Skip if too small to be a Lob (GameConfig is smaller)
            if (data.length < 80) continue;

            // Skip the 8-byte discriminator
            let offset = 8;

            // owner: Pubkey (32 bytes)
            const owner = new PublicKey(data.slice(offset, offset + 32));
            offset += 32;

            // name: String (4 byte length prefix + bytes)
            const nameLen = data.readUInt32LE(offset);
            offset += 4;
            if (nameLen > 32 || offset + nameLen > data.length) continue;
            const name = data.slice(offset, offset + nameLen).toString("utf8");
            offset += nameLen;

            // species: u8
            const species = data.readUInt8(offset);
            offset += 1;
            if (species > 5) continue; // Not a Lob account

            // xp: u32
            const xp = data.readUInt32LE(offset);
            offset += 4;

            // strength: u8
            const strength = data.readUInt8(offset);
            offset += 1;

            // vitality: u8
            const vitality = data.readUInt8(offset);
            offset += 1;

            // speed: u8
            const speed = data.readUInt8(offset);
            offset += 1;

            // mood: u8
            const mood = data.readUInt8(offset);
            offset += 1;

            // last_fed: i64
            const lastFed = Number(data.readBigInt64LE(offset));
            offset += 8;

            // battles_won: u32
            const battlesWon = data.readUInt32LE(offset);
            offset += 4;

            // battles_lost: u32
            const battlesLost = data.readUInt32LE(offset);
            offset += 4;

            // evolution_stage: u8
            const evolutionStage = data.readUInt8(offset);
            offset += 1;

            // is_alive: bool
            const isAlive = data.readUInt8(offset) === 1;
            offset += 1;

            // mint_index: u64
            const mintIndex = Number(data.readBigUInt64LE(offset));
            offset += 8;

            parsed.push({
              address: pubkey,
              owner,
              name,
              species,
              xp,
              strength,
              vitality,
              speed,
              mood,
              lastFed,
              battlesWon,
              battlesLost,
              evolutionStage,
              isAlive,
              mintIndex,
            });
          } catch {
            // Skip malformed accounts
            continue;
          }
        }

        // Sort by mint index (oldest first)
        parsed.sort((a, b) => a.mintIndex - b.mintIndex);

        if (!cancelled) {
          setLobs(parsed);
          setLoading(false);
        }
      } catch (err: any) {
        if (!cancelled) {
          setError(err.message || "Failed to fetch");
          setLoading(false);
        }
      }
    }

    fetchLobs();

    // Refresh every 30 seconds
    const interval = setInterval(fetchLobs, 30000);

    return () => {
      cancelled = true;
      clearInterval(interval);
    };
  }, []);

  return { lobs, loading, error };
}
