import {
  AnchorProvider,
  Program,
  Idl,
  BN,
  Wallet,
} from "@coral-xyz/anchor";
import {
  Connection,
  PublicKey,
  SystemProgram,
  Keypair,
  Transaction,
  sendAndConfirmTransaction,
} from "@solana/web3.js";
import {
  LobData,
  GameConfigData,
  BattleResult,
  Species,
  EvolutionStage,
} from "./types";
import {
  deriveConfigPda,
  deriveTreasuryPda,
  deriveLobPda,
  SLOT_HASHES_SYSVAR,
} from "./utils";

// The IDL will be generated by `anchor build`
// For now, we reference it by path â€” users import after building
import type { Lobs as LobsIDL } from "../../target/types/lobs";

export class LobsClient {
  readonly program: Program<LobsIDL>;
  readonly connection: Connection;
  readonly wallet: Wallet;
  readonly programId: PublicKey;

  private configPda: PublicKey;
  private configBump: number;
  private treasuryPda: PublicKey;

  constructor(
    connection: Connection,
    wallet: Wallet,
    programId: PublicKey,
    idl: Idl
  ) {
    this.connection = connection;
    this.wallet = wallet;
    this.programId = programId;

    const provider = new AnchorProvider(connection, wallet, {
      commitment: "confirmed",
    });

    this.program = new Program(idl as any, provider) as unknown as Program<LobsIDL>;

    [this.configPda, this.configBump] = deriveConfigPda(programId);
    [this.treasuryPda] = deriveTreasuryPda(programId);
  }

  /** Initialize the game (one-time setup) */
  async initialize(): Promise<string> {
    const tx = await this.program.methods
      .initialize()
      .accounts({
        authority: this.wallet.publicKey,
        config: this.configPda,
        treasury: this.treasuryPda,
        systemProgram: SystemProgram.programId,
      })
      .rpc();

    return tx;
  }

  /** Mint a new Lob */
  async mintLob(name: string): Promise<{ lob: LobData; txSignature: string }> {
    const config = await this.getConfig();
    const mintIndex = config.totalLobsMinted;

    const [lobPda] = deriveLobPda(
      this.programId,
      this.wallet.publicKey,
      mintIndex
    );

    const tx = await this.program.methods
      .mintLob(name)
      .accounts({
        owner: this.wallet.publicKey,
        config: this.configPda,
        lob: lobPda,
        slotHashes: SLOT_HASHES_SYSVAR,
        systemProgram: SystemProgram.programId,
      })
      .rpc();

    const lob = await this.getLob(lobPda);
    return { lob, txSignature: tx };
  }

  /** Feed a Lob (costs 0.001 SOL) */
  async feedLob(lobAddress: PublicKey): Promise<string> {
    const tx = await this.program.methods
      .feedLob()
      .accounts({
        owner: this.wallet.publicKey,
        config: this.configPda,
        lob: lobAddress,
        treasury: this.treasuryPda,
        systemProgram: SystemProgram.programId,
      })
      .rpc();

    return tx;
  }

  /** Battle another agent's Lob */
  async battle(
    myLobAddress: PublicKey,
    opponentLobAddress: PublicKey
  ): Promise<BattleResult> {
    const beforeChallenger = await this.getLob(myLobAddress);
    const beforeChallengerWins = beforeChallenger.battlesWon;

    const tx = await this.program.methods
      .battle()
      .accounts({
        challenger: this.wallet.publicKey,
        challengerLob: myLobAddress,
        defenderLob: opponentLobAddress,
        slotHashes: SLOT_HASHES_SYSVAR,
      })
      .rpc();

    const afterChallenger = await this.getLob(myLobAddress);
    const challengerWon = afterChallenger.battlesWon > beforeChallengerWins;

    return {
      txSignature: tx,
      challengerWon,
      challengerLob: myLobAddress,
      defenderLob: opponentLobAddress,
    };
  }

  /** Evolve a Lob to the next stage */
  async evolveLob(lobAddress: PublicKey): Promise<string> {
    const tx = await this.program.methods
      .evolveLob()
      .accounts({
        owner: this.wallet.publicKey,
        lob: lobAddress,
      })
      .rpc();

    return tx;
  }

  /** Fetch a single Lob by address */
  async getLob(address: PublicKey): Promise<LobData> {
    const account = await this.program.account.lob.fetch(address);
    return {
      address,
      owner: account.owner,
      name: account.name,
      species: account.species as Species,
      xp: account.xp,
      strength: account.strength,
      vitality: account.vitality,
      speed: account.speed,
      mood: account.mood,
      lastFed: (account.lastFed as any as BN).toNumber(),
      battlesWon: account.battlesWon,
      battlesLost: account.battlesLost,
      evolutionStage: account.evolutionStage as EvolutionStage,
      isAlive: account.isAlive,
      mintIndex: (account.mintIndex as any as BN).toNumber(),
      bump: account.bump,
    };
  }

  /** Fetch all Lobs in the game */
  async getAllLobs(): Promise<LobData[]> {
    const accounts = await this.program.account.lob.all();
    return accounts.map((a) => ({
      address: a.publicKey,
      owner: a.account.owner,
      name: a.account.name,
      species: a.account.species as Species,
      xp: a.account.xp,
      strength: a.account.strength,
      vitality: a.account.vitality,
      speed: a.account.speed,
      mood: a.account.mood,
      lastFed: (a.account.lastFed as any as BN).toNumber(),
      battlesWon: a.account.battlesWon,
      battlesLost: a.account.battlesLost,
      evolutionStage: a.account.evolutionStage as EvolutionStage,
      isAlive: a.account.isAlive,
      mintIndex: (a.account.mintIndex as any as BN).toNumber(),
      bump: a.account.bump,
    }));
  }

  /** Fetch all Lobs owned by the connected wallet */
  async getMyLobs(): Promise<LobData[]> {
    const all = await this.getAllLobs();
    return all.filter(
      (lob) => lob.owner.toString() === this.wallet.publicKey.toString()
    );
  }

  /** Fetch game config */
  async getConfig(): Promise<GameConfigData> {
    const config = await this.program.account.gameConfig.fetch(this.configPda);
    return {
      address: this.configPda,
      authority: config.authority,
      totalLobsMinted: (config.totalLobsMinted as any as BN).toNumber(),
      bump: config.bump,
      treasuryBump: config.treasuryBump,
    };
  }
}
